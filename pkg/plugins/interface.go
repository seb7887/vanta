package plugins

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"github.com/valyala/fasthttp"
	"go.uber.org/zap"
)

// Plugin represents the base interface that all plugins must implement.
// It provides basic lifecycle management and metadata for plugins.
type Plugin interface {
	// Name returns the unique name of the plugin
	Name() string

	// Version returns the version of the plugin
	Version() string

	// Description returns a human-readable description of the plugin
	Description() string

	// Init initializes the plugin with the provided configuration.
	// This is called once during plugin registration.
	Init(ctx context.Context, config map[string]interface{}, logger *zap.Logger) error

	// Cleanup performs any necessary cleanup when the plugin is being unloaded.
	// This is called during graceful shutdown or plugin hot-reload.
	Cleanup(ctx context.Context) error
}

// Priority defines the execution order of plugins within the same category.
// Lower values have higher priority (execute first).
type Priority int

const (
	PriorityHigh   Priority = 0
	PriorityNormal Priority = 100
	PriorityLow    Priority = 200
)

// Middleware represents a plugin that provides FastHTTP middleware functionality.
// It extends the base Plugin interface with HTTP-specific capabilities.
type Middleware interface {
	Plugin

	// Priority returns the execution priority of this middleware.
	// Used to determine the order of middleware execution.
	Priority() Priority

	// PreProcess is called before the request reaches the main handler.
	// It can modify the request, add context values, or short-circuit the request.
	// Return true to continue processing, false to stop the middleware chain.
	PreProcess(ctx *RequestContext) (bool, error)

	// PostProcess is called after the main handler has processed the request.
	// It can modify the response or perform cleanup operations.
	PostProcess(ctx *ResponseContext) error

	// ShouldApply determines if this middleware should be applied to the given request.
	// This allows for conditional middleware application based on path, method, etc.
	ShouldApply(req *fasthttp.RequestCtx) bool
}

// RequestProcessor processes incoming HTTP requests before they reach handlers.
// This is useful for authentication, rate limiting, request validation, etc.
type RequestProcessor interface {
	Plugin

	// ProcessRequest processes the incoming request.
	// It can modify the request, reject it, or add metadata for downstream processing.
	ProcessRequest(ctx *RequestContext) (*RequestResult, error)

	// SupportsMethod returns true if this processor supports the given HTTP method.
	SupportsMethod(method string) bool

	// SupportsPath returns true if this processor should handle requests to the given path.
	SupportsPath(path string) bool
}

// ResponseProcessor processes HTTP responses after they're generated by handlers.
// This is useful for response transformation, caching, compression, etc.
type ResponseProcessor interface {
	Plugin

	// ProcessResponse processes the outgoing response.
	// It can modify headers, body, status code, or add additional metadata.
	ProcessResponse(ctx *ResponseContext) (*ResponseResult, error)

	// SupportsContentType returns true if this processor supports the given content type.
	SupportsContentType(contentType string) bool

	// SupportsStatusCode returns true if this processor should handle the given status code.
	SupportsStatusCode(statusCode int) bool
}

// RequestContext contains request-specific data and utilities for plugin processing.
type RequestContext struct {
	// FastHTTP request context
	RequestCtx *fasthttp.RequestCtx

	// Request metadata and processing state
	RequestID  string
	StartTime  time.Time
	UserValues map[string]interface{}

	// Plugin-specific context for sharing data between plugins
	PluginData map[string]interface{}

	// Logger with request-specific fields
	Logger *zap.Logger

	// Cancellation context
	Context context.Context

	// Thread-safe access to shared data
	mu sync.RWMutex
}

// ResponseContext contains response-specific data and utilities for plugin processing.
type ResponseContext struct {
	// All fields from RequestContext
	*RequestContext

	// Response processing time
	ProcessingTime time.Duration

	// Response body (may be nil if not captured)
	ResponseBody []byte

	// Error that occurred during request processing (if any)
	ProcessingError error
}

// RequestResult represents the result of request processing by a plugin.
type RequestResult struct {
	// Continue indicates whether processing should continue to the next plugin/handler
	Continue bool

	// Modified indicates whether the request was modified by this plugin
	Modified bool

	// Error indicates an error occurred during processing
	Error error

	// StatusCode to return if Continue is false (short-circuit response)
	StatusCode int

	// ResponseBody to return if Continue is false
	ResponseBody []byte

	// ResponseHeaders to add/modify
	ResponseHeaders map[string]string

	// Metadata for downstream plugins
	Metadata map[string]interface{}
}

// ResponseResult represents the result of response processing by a plugin.
type ResponseResult struct {
	// Modified indicates whether the response was modified by this plugin
	Modified bool

	// Error indicates an error occurred during processing
	Error error

	// NewStatusCode replaces the original status code if non-zero
	NewStatusCode int

	// NewBody replaces the original response body if non-nil
	NewBody []byte

	// HeadersToAdd contains headers to add to the response
	HeadersToAdd map[string]string

	// HeadersToRemove contains header names to remove from the response
	HeadersToRemove []string

	// Metadata for downstream plugins
	Metadata map[string]interface{}
}

// PluginError represents errors that occur during plugin operations.
type PluginError struct {
	PluginName string
	Operation  string
	Message    string
	Cause      error
}

// Error implements the error interface.
func (e *PluginError) Error() string {
	if e.Cause != nil {
		return fmt.Sprintf("plugin %s: %s: %s: %v", e.PluginName, e.Operation, e.Message, e.Cause)
	}
	return fmt.Sprintf("plugin %s: %s: %s", e.PluginName, e.Operation, e.Message)
}

// Unwrap returns the underlying error.
func (e *PluginError) Unwrap() error {
	return e.Cause
}

// Is checks if the error is of a specific type.
func (e *PluginError) Is(target error) bool {
	if target == nil {
		return false
	}
	
	if pe, ok := target.(*PluginError); ok {
		return e.PluginName == pe.PluginName && e.Operation == pe.Operation
	}
	
	return errors.Is(e.Cause, target)
}

// Common plugin errors
var (
	ErrPluginNotFound      = errors.New("plugin not found")
	ErrPluginAlreadyExists = errors.New("plugin already exists")
	ErrPluginInitFailed    = errors.New("plugin initialization failed")
	ErrPluginConfigInvalid = errors.New("plugin configuration invalid")
	ErrPluginNotEnabled    = errors.New("plugin not enabled")
	ErrPluginTimeout       = errors.New("plugin operation timed out")
)

// NewPluginError creates a new plugin error.
func NewPluginError(pluginName, operation, message string, cause error) *PluginError {
	return &PluginError{
		PluginName: pluginName,
		Operation:  operation,
		Message:    message,
		Cause:      cause,
	}
}

// RequestContext utility methods

// SetUserValue stores a value in the request context in a thread-safe manner.
func (rc *RequestContext) SetUserValue(key string, value interface{}) {
	rc.mu.Lock()
	defer rc.mu.Unlock()
	if rc.UserValues == nil {
		rc.UserValues = make(map[string]interface{})
	}
	rc.UserValues[key] = value
}

// GetUserValue retrieves a value from the request context in a thread-safe manner.
func (rc *RequestContext) GetUserValue(key string) (interface{}, bool) {
	rc.mu.RLock()
	defer rc.mu.RUnlock()
	if rc.UserValues == nil {
		return nil, false
	}
	val, exists := rc.UserValues[key]
	return val, exists
}

// SetPluginData stores plugin-specific data in a thread-safe manner.
func (rc *RequestContext) SetPluginData(pluginName, key string, value interface{}) {
	rc.mu.Lock()
	defer rc.mu.Unlock()
	if rc.PluginData == nil {
		rc.PluginData = make(map[string]interface{})
	}
	pluginKey := fmt.Sprintf("%s.%s", pluginName, key)
	rc.PluginData[pluginKey] = value
}

// GetPluginData retrieves plugin-specific data in a thread-safe manner.
func (rc *RequestContext) GetPluginData(pluginName, key string) (interface{}, bool) {
	rc.mu.RLock()
	defer rc.mu.RUnlock()
	if rc.PluginData == nil {
		return nil, false
	}
	pluginKey := fmt.Sprintf("%s.%s", pluginName, key)
	val, exists := rc.PluginData[pluginKey]
	return val, exists
}

// Method returns the HTTP method of the request.
func (rc *RequestContext) Method() string {
	return string(rc.RequestCtx.Method())
}

// Path returns the request path.
func (rc *RequestContext) Path() string {
	return string(rc.RequestCtx.Path())
}

// Header returns the value of the given request header.
func (rc *RequestContext) Header(name string) string {
	return string(rc.RequestCtx.Request.Header.Peek(name))
}

// Query returns the value of the given query parameter.
func (rc *RequestContext) Query(name string) string {
	return string(rc.RequestCtx.QueryArgs().Peek(name))
}

// Body returns the request body.
func (rc *RequestContext) Body() []byte {
	return rc.RequestCtx.Request.Body()
}

// RemoteAddr returns the remote address of the client.
func (rc *RequestContext) RemoteAddr() string {
	return rc.RequestCtx.RemoteAddr().String()
}

// UserAgent returns the User-Agent header value.
func (rc *RequestContext) UserAgent() string {
	return string(rc.RequestCtx.UserAgent())
}

// ContentType returns the Content-Type header value.
func (rc *RequestContext) ContentType() string {
	return string(rc.RequestCtx.Request.Header.ContentType())
}

// RequestResult utility methods

// NewRequestResult creates a new RequestResult with default values.
func NewRequestResult() *RequestResult {
	return &RequestResult{
		Continue:        true,
		Modified:        false,
		ResponseHeaders: make(map[string]string),
		Metadata:        make(map[string]interface{}),
	}
}

// Stop configures the result to stop processing and return a response.
func (rr *RequestResult) Stop(statusCode int, body []byte) *RequestResult {
	rr.Continue = false
	rr.StatusCode = statusCode
	rr.ResponseBody = body
	return rr
}

// AddHeader adds a response header.
func (rr *RequestResult) AddHeader(name, value string) *RequestResult {
	if rr.ResponseHeaders == nil {
		rr.ResponseHeaders = make(map[string]string)
	}
	rr.ResponseHeaders[name] = value
	return rr
}

// SetMetadata sets metadata for downstream plugins.
func (rr *RequestResult) SetMetadata(key string, value interface{}) *RequestResult {
	if rr.Metadata == nil {
		rr.Metadata = make(map[string]interface{})
	}
	rr.Metadata[key] = value
	return rr
}

// ResponseResult utility methods

// NewResponseResult creates a new ResponseResult with default values.
func NewResponseResult() *ResponseResult {
	return &ResponseResult{
		Modified:        false,
		HeadersToAdd:    make(map[string]string),
		HeadersToRemove: make([]string, 0),
		Metadata:        make(map[string]interface{}),
	}
}

// SetBody sets a new response body.
func (rr *ResponseResult) SetBody(body []byte) *ResponseResult {
	rr.NewBody = body
	rr.Modified = true
	return rr
}

// SetStatusCode sets a new status code.
func (rr *ResponseResult) SetStatusCode(statusCode int) *ResponseResult {
	rr.NewStatusCode = statusCode
	rr.Modified = true
	return rr
}

// AddHeader adds a response header.
func (rr *ResponseResult) AddHeader(name, value string) *ResponseResult {
	if rr.HeadersToAdd == nil {
		rr.HeadersToAdd = make(map[string]string)
	}
	rr.HeadersToAdd[name] = value
	rr.Modified = true
	return rr
}

// RemoveHeader marks a header for removal.
func (rr *ResponseResult) RemoveHeader(name string) *ResponseResult {
	rr.HeadersToRemove = append(rr.HeadersToRemove, name)
	rr.Modified = true
	return rr
}

// SetMetadata sets metadata for downstream plugins.
func (rr *ResponseResult) SetMetadata(key string, value interface{}) *ResponseResult {
	if rr.Metadata == nil {
		rr.Metadata = make(map[string]interface{})
	}
	rr.Metadata[key] = value
	return rr
}

// PluginCapabilities defines optional capabilities that plugins can implement.
type PluginCapabilities struct {
	// SupportsHotReload indicates if the plugin supports hot reloading
	SupportsHotReload bool

	// SupportsMetrics indicates if the plugin exposes metrics
	SupportsMetrics bool

	// SupportsHealthCheck indicates if the plugin provides health checks
	SupportsHealthCheck bool

	// SupportsConfiguration indicates if the plugin supports runtime configuration changes
	SupportsConfiguration bool
}

// PluginMetadata contains metadata about a plugin.
type PluginMetadata struct {
	Name         string
	Version      string
	Description  string
	Author       string
	License      string
	Homepage     string
	Capabilities PluginCapabilities
	Dependencies []string
	Tags         []string
}

// ConfigurablePlugin represents a plugin that supports runtime configuration changes.
type ConfigurablePlugin interface {
	Plugin

	// UpdateConfig updates the plugin configuration at runtime.
	UpdateConfig(ctx context.Context, config map[string]interface{}) error

	// GetConfig returns the current plugin configuration.
	GetConfig() map[string]interface{}

	// ValidateConfig validates the provided configuration without applying it.
	ValidateConfig(config map[string]interface{}) error
}

// MetricsProvider represents a plugin that provides metrics.
type MetricsProvider interface {
	Plugin

	// GetMetrics returns current metrics data.
	GetMetrics() map[string]interface{}

	// ResetMetrics resets the plugin's metrics.
	ResetMetrics() error
}

// HealthChecker represents a plugin that provides health check functionality.
type HealthChecker interface {
	Plugin

	// HealthCheck performs a health check and returns the status.
	HealthCheck(ctx context.Context) HealthStatus
}

// HealthStatus represents the health status of a plugin.
type HealthStatus struct {
	Healthy bool
	Message string
	Details map[string]interface{}
	LastCheck time.Time
}

// HotReloadable represents a plugin that supports hot reloading.
type HotReloadable interface {
	Plugin

	// Reload reloads the plugin configuration and state.
	Reload(ctx context.Context, config map[string]interface{}) error

	// CanReload returns true if the plugin can be safely reloaded.
	CanReload() bool
}